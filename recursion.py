# # Рекурсия
#
# рекурсывный алгоритм пишется следующим образомЖ
# функция внутри функции,иными словами, внутри функции или метода вызывается либо другая функция,
# либо эта же самая, образуя таким образом замыкание
#
# Код внутри вложенной функции меняет данные и возвращает их в новую,
# скажем так, итерацию функции (вызов функции самого себя)
#
# по этой причине в функции должна присутствовать терминальная ветвь -
# условие, которое завершает рекурсивный алгоритм, останавливая его навсегда
#
# 3 закона рекурсии:
# 1) У рекурсивного алгоритма должны быть как минимум одна рекурсивная
# и одна терминальная ветвь.
# 2) курсивный алгоритм должен менять свое состояние и стремиться к терминальной ветви.
# 3) Рекурсивный алгоритм должен вызывать себя рекурсивно.
#
# Рассмотрим 2 варианта функции определяющей факториал - итеративную (циклическую) и рекурсивную:
#
# итеративная:

def iteration_factorial(n: int) -> int:
    the_product = 1
    while n > 0:
        the_product *= n
        n -= 1
    return the_product

# рекурсивный

def recursion_factorial(n: int) -> int:
    if n == 0: # терминальная ветвь
        return 1
    return n * recursion_factorial(n - 1) # рекурсивная ветвь

# рекурсивная ветвь выполняется до тех пор, пока n не будет равно нулю
# в противном случае вызывается терминальная ветвь,возвращающая единицу
#
# самостоятельное задание - вывести числа от 1 до 10 методом рекурсии

def recursion_one_ten(n: int) -> int:
    if n == 1:
        print(1)

