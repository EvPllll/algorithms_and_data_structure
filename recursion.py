# # # Рекурсия
# #
# # рекурсывный алгоритм пишется следующим образомЖ
# # функция внутри функции,иными словами, внутри функции или метода вызывается либо другая функция,
# # либо эта же самая, образуя таким образом замыкание
# #
# # Код внутри вложенной функции меняет данные и возвращает их в новую,
# # скажем так, итерацию функции (вызов функции самого себя)
# #
# # по этой причине в функции должна присутствовать терминальная ветвь -
# # условие, которое завершает рекурсивный алгоритм, останавливая его навсегда
# #
# # 3 закона рекурсии:
# # 1) У рекурсивного алгоритма должны быть как минимум одна рекурсивная
# # и одна терминальная ветвь.
# # 2) курсивный алгоритм должен менять свое состояние и стремиться к терминальной ветви.
# # 3) Рекурсивный алгоритм должен вызывать себя рекурсивно.
# #
# # Рассмотрим 2 варианта функции определяющей факториал - итеративную (циклическую) и рекурсивную:
# #
# # итеративная:
#
# def iteration_factorial(n: int) -> int:
#     the_product = 1
#     while n > 0:
#         the_product *= n
#         n -= 1
#     return the_product
#
# # рекурсивный
#
# def recursion_factorial(n: int) -> int:
#     if n == 0: # терминальная ветвь
#         return 1
#     return n * recursion_factorial(n - 1) # рекурсивная ветвь

#
# # рекурсивная ветвь выполняется до тех пор, пока n не будет равно нулю
# # в противном случае вызывается терминальная ветвь,возвращающая единицу
# #
# # самостоятельное задание - вывести числа от 1 до 10 методом рекурсии

# def recursion_one_ten(n: int) -> int: # рекурсивный алгоритм, который выводит числа от 1 до n
#     if n != 1:
#         recursion_one_ten(n - 1)
#     print(n)
#
#
# print(recursion_one_ten(5))

# # минус в том, что в конце выводится None
# минус рекурсии в том, что для её выполнения создаётся дополнительный стек,
# который использует больше памяти, поэтому использование рекурсии позволительно тогда,
# когда нет дефицита используемой памяти
#
# а так же большой плюс рекурсии в том, что она делает решение задачи более элегантным)
