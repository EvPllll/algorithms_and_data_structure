# # БАЗОВЫЕ ПОНЯТИЯ
#
# from datetime import datetime # импортируем библиотеку datetime
#
# def dec_test_time(func): # функция декоратор с параметром получаемой функции
#     def wrapper(*args, **kwargs): # функция декоратор с множеством параметров
#         start = datetime.now() # определяем время старта
#         result = func(*args, **kwargs) # функция, которую декорируют с множеством параметров
#         end = datetime.now() # время окончания
#         delta_time = (end - start).total_seconds() * 10**3 # разница во времени в миллисекундах
#         print(f'Time executing: {delta_time} ms') # вывод времени
#         return result # если функция в параметре декоратора возвращает результат, то возвращаем результат и тут
#     return wrapper # возвращаем декоратор
#
# @dec_test_time # таким образом применяем декоратор к функции
# def my_program(a, n):
#     for i in range(n):
#         a += i**100
#     return a
#
# res = my_program(0, 10000000)
# print(res)
#
# # определение эффективности алгоритма по времени выполнения - не самое лучшее решение
# # лучше определять эффективность по кол-ву шагов до конца выполнения программы
#
# for i in range(6):
#     print(i)
#     # 6 шагов
#
# a = 0
# for i in range(6):
#     print(i)
#     a += i
#     # 11 шагов
#
# # О большое, то есть О() - обозначение сложности алгоритма, например:
# for i in range(n):
#     print(n)
# будет равен сложности О(n), т.к. для выполнения алгоритму нужно проти n шагов.
#
# если:
# for i in range(n):
#     for j in range(n):
#         print(i, j)
# то сложность будет О(n**2), т.к. вложенный цикл проходит операций n**2 раз для каждой итерации i
#
# О большое - это математическое обозначение, описывающее, как по мере роста n
# возрастают требования алгоритма к времени и объему памяти
#
# Порядок величины T(n) - тип объекта в системе классификации,
# в которой каждый тип во много раз больше или меньше предыдущего
#
# Классификации О большое:
#     - постоянное время О(1)
#     - логарифметическое время О(log(n))
#     - линейное время О(n)
#     - линейно-логарифметическое время O(n * log(n))
#     - квадратичное время O(n**2)
#     - кубическое время O(n**3), полиноминальное O(n**a)
#     - экспонениальное время O(c**n)
#
# Временная сложность — это максимальное количество шагов, требующихся
# алгоритму для завершения по мере увеличения n
#
# Постоянное время O(1)
#
# Например, мы дарим одну книгу первому покупателю
# free_books = customers[0]
# В этом случае Т(n) = 1, т.е. независимо от данных программа выполняется одинаково.
#
# Логарифметическое время О(log(n))
# Примером может послужить двоичный поиск (о нём позже)
#
# Линейное время О(n)
# Например, когда мы дарим книгу не первому покупателю, а тем, чьё имя начинается на D
#
# free_books = False
# customers = [john, Steven, David, Ann, Lisa, Don]
# for customer in customers:
#     if customer[0] == 'D':
#         print(customer)
#
# Сложность алгоритма зависит от кол-ва покупателей (данных), т.к. для определения необхдимо
# пройти по каждому покупателю.
#
# Линейно-логарифметическое время O(n * log(n))
# Например, большинство сортировок имеют эту временную сложность (о них тоже позже)
#
# Квадратичное время O(n**2)
# например
#
# numbers = [1, 2, 3, 4, 5]
# for i in numbers:
#     for j in numbers:
#         x = i * j
#         print(x)
#
# большинство вложенных циклов имеют именно такую сложность.
#
# Кубическое время O(n**3)
#
# numbers = [1, 2, 3, 4, 5]
# for i in numbers:
#     for j in numbers:
#         for h in numbers:
#             x = i * j
#             print(x)
#
# 3 цикла. соответственно n**3.
# Этим принципом пользуется полиномиальное время О(n**a)? где a = кол-во циклов,
# например 2 - квадратичное время, 3 - кубическое время и т.д.
#
# Экспоненциальное время О(c**n)
# c - это константа
#
# например, мы хотим угодать пароль, состоящий из десятичных знаков методом перебора
# в таком случае будет О(10**n), где n - длина пароля.
#
# password = 64738
# n = len(password)
# for i in range(10**n):
#     if i == password:
#         print(i)
#
# Это так называемые алгоритм полного перебора - такие лучше не использовать.
# Очень долго выполняется.
#
# Сложность в худшем и лучшем случаях.
# например
#
# a = 56
# for i in range(100):
#     if i == a:
#         print('WIN')
#
# лучший случай, это, если бы a был равен 0, тогда WIN был бы уже на первой итерации (О(1))
# худший случай, это, если бы a был равен 99, тогда WIN был бы на послудней итерации (О(n))
# средний случай получется при О(n/2)
#
# Фиксированная и пространственная сложность
#
# Фиксированная сложность - кол-во памяти, которое необходимо для выполнения алгоритма
# Пространственная сложность - это объем необходимой алгоритму
# памяти, включающий в себя фиксированное пространство, пространство струк-
# туры данных и вр менное пространство
# Пространство структуры данных - это объем памяти, необходимый программе для хранения на-
# бора данных, например, размер списка, в котором ведется поиск.
# например, факториал
#
# x = 1
# n = 5
# for i in range(1, n + 1):
#     x *= i
# Это сложность О(1) - т.к. мы ничего никуда не записываем, а просто вычисляем произведение всех чисел от 1 до 5
#
# А если бы мы каждую итерацию записывали все факторилы в списке то
#
# x = 1
# n = 5
# lst = []
# for i in range(1, n + 1):
#     lst.append(x)
#     x *= i
# это сложность О(n), т.к. объём памяти увеличивается с каждой итерацией объекта и добавлением элементов в список.
#
# В целом, если резюмировать всё вышеописанное, то
# 1) ЧЕМ МЕНЬШЕ ВРЕМЕНИ И РЕСУРСОВ ТРЕБУЕТ УСПЕШНОЕ ВЫПОЛНЕНИЕ АЛГОРИТМА, ТЕМ ЛУЧШЕ.
# 2) ЧЕМ МЕНЬШИЙ ПОРЯДОК ВЕЛИЧИНЫ ИСПОЛЬЗУЕТСЯ, ТЕМ ЛУЧШЕ.
#
#
#
#
#
#
#
#
#
